---
title: "OpenAPI定義から"
emoji: "🐕"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["TypeScript", "openapitypescript", "Nodejs"]
published: false
---
## はじめに

OpenAPI Specification（以下、OAS）は、一般的にAPI仕様のドキュメンテーションとして活用されるケースが多いと思います。
しかしOASには、ドキュメンテーション以外にも、様々な活用方法が存在しています。

以下は、Swagger.ioのホームページから引用しています。

またOASは、サードパーティ製のツールも豊富です。

私が携わっているプロダクトでは、OASが開発初期からドキュメンテーション（一部バリデーション）として利用していました。
今回新たなサードパーティ製のツールを導入して、OASの下記のような活用を図りました。
1. **OASからtypescript型定義を生成し、バックエンド・フロントエンドで共用する**
2. **APIのバリデーションにOASを用いる**

なお、プロダクトのおおまかな技術構成は下記になります。
フロントエンドはNext.js、バックエンドはExpressでAPIサーバーを立てる構成です。


## OASからtypescript型定義を生成し、バックエンド・フロントエンドで共用する
### 解決したかった課題
プロダクトは、スタートアップでスピード重視で開発が進められていたこともあり、様々な問題が潜んでいました。
その一つとして、フロントエンドのAPIレスポンスの型定義が実態とそぐわず、バグの温床や開発効率を低下させているという課題がありました。

OASから生成した型をバックエンド・フロントエンドで共有することで、型の安全性を担保できます。
型生成のライブラリとしては、openapi-typescriptを用いていました。

### openapi-typescript
#### 選定理由
より一般的なライブラリとして、[OpenAPI Generator](https://github.com/OpenAPITools/openapi-generator)があります。
しかし以下の理由から、openapi-typescriptを選択しました。
- typescript製のライブラリであり、プロダクトの技術構成と相性が良く、内部実装の把握やメンテナンスの面でメリットがある
- [transform](https://github.com/drwpow/openapi-typescript#-transform--posttransform:~:text=transform%20/%20postTransform)で柔軟に型を生成できる ※後述

### アーキテクチャ
openapi-typescriptを導入後のアーキテクチャイメージです。

#### ディレクトリ構成
下記はopenapiディレクトリの構成です。
なお実際のディレクトリ/ファイル名とは一部異なります。

```txt
.
└── openapi
    ├── bin
    │   ├── generatedTypes.js #src/docs配下の定義から、generatedTypes配下に型ファイルを生成する。
    │   └── merge.js #define配下の定義を結合し、src/docs配下のファイルを生成する。generatedTypes.jsの中で呼ばれる。
    ├── define
    │   ├── auth
    │   │   ├── components.yml
    │   │   ├── path.yml
    │   │   └── index.yml
    │   └── users
    │       ├── components.yml
    │       ├── path.yml
    │       └── index.yml
    └── src
        ├── docs
        │   ├── auth.yml
        │   └── users.yml
        ├── generatedTypes
        │   ├── auth.ts
        │   └── users.ts
        ├── types
        │   ├── auth.ts #実際にバックエンド/フロントエンドで使用されるファイル群。
        │   └── users.ts
        └── utils
            └── helper.ts #src/types配下のファイルで利用される。
```
特徴としては、ドメイン単位(auth, users)でディレクトリを設けている点です。
OASやそこから生成する型ファイルを1ファイルで管理しようとすると、あまりにファイルが肥大化してしまいます。

#### スクリプト化
``bin/generatedTypes.js``は、openapi-typescriptのAPIを実行します。そして、``src/generatedTypes``及び``src/docs``配下のファイル群を生成します。

``bin/generatedTypes.js``の概要です。
一部加筆しており、実際のスクリプトとは異なります。

```js
import * as fs from "fs";
import yaml from "js-yaml"
import openapiTS from "openapi-typescript";
import mergeDefine from "./merge.js"

const makeDir = async (dir) => {
  //docs配下に既存のディレクトリがない場合は作成する。
  const path = `openapi/src/docs/${dir}`
  if (!fs.existsSync(path)) {
    fs.mkdirSync(path);
  }
}

const callMergeDefine = async (dir) => {
  //bin/merge.jsを実行する。define配下の定義を結合し、src/docs配下のファイルを生成する
  const input = `openapi/define/${dir}/index.yml`
  const output = `openapi/src/docs/${dir}/index.yml`
  mergeDefine(input, output)
}

const openapiTSFunc = async (data) => {
  //型をtransformする。
  const output = await openapiTS(data, {
    formatter(node) {
      if (node.format === "date-time") {
        return "Date"; 
      }
    }
  })
  return output
}

const generateTypes = async (dir) => {
  const filePath = `openapi/src/docs/${dir}/index.yml`
  const fileData = fs.readFileSync(filePath, "utf-8")
  const data = yaml.load(fileData)
  //型を生成し、ファイルに書き込む。
  const output = await openapiTSFunc(data)
  fs.writeFileSync(`openapi/src/generatedTypes/${dir}.ts`, output)
}

const main = async () => {
  const defineDirLists = fs.readdirSync('openapi/define')

  await Promise.all(defineDirLists.map(async dir => {
    await makeDir(dir)
    await callMergeDefine(dir)
    await generateTypes(dir)
  }))
}

main()
```

このスクリプトは、huskyとlint-stagedを用いて、commit時に自動で実行されるようになっています。
これにより、開発者間でのQASや生成される型ファイルの差異をなくしています。

#### transform
諸事情あって、自動で生成される型を任意に設定する必要がありました。
openapi-typescriptの[transform](https://github.com/drwpow/openapi-typescript#-transform--posttransform:~:text=transform%20/%20postTransform)は非常に便利です。

```yml
type: object
      properties:
        id:
          type: integer
          format: number-bigint #任意に命名
          example: 1
```

このようにformatを任意に命名しておき、上記スクリプトで記述したように、自由に生成される型を設定できます。


#### helper
openapi-typescriptの残念な点は、生成される型がネストされ複雑なので、そのままでは利用しづらいところです。
そこで``src/types``配下において、``utils/helper.ts``を用いて、利用しやすい型を再定義しています。

##### 生成される型の例
```typescript
/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/auth": {
    get: {
      responses: {
        200: {
          content: {
            "application/json": {
              key: string
            }[];
          };
        };
        /** Not logged in */
        401: unknown;
        /** Unauthorized */
        403: unknown;
      };
    };
    patch: {
      responses: {
        200: unknown;
        /** Not logged in */
        401: unknown;
        /** Unauthorized */
        403: unknown;
      };
      requestBody: {
        content: {
          "application/json": {
            /** @example 1 */
            id: number;
          }[];
        };
      };
    };
  };
}

export interface components {}

export interface operations {}

export interface external {}
```

##### src/utils/helper.ts
```typescript
type UrlPaths<paths> = keyof paths & string
type HttpMethods = 'patch' | 'get'

export type ResponseBodyType<
  paths extends {
    [k in Path]: {
      [k in Method]: {
        responses: {
          200: {
            content: {
              "application/json": object | Array<object>
            }
          }
        }
      }
    }
  },
  Path extends UrlPaths<paths>,
  Method extends HttpMethods 
> = paths[Path][Method]['responses'][200]['content']["application/json"]

export type RequestBodyType<
  paths extends {
    [k in Path]: {
      [k in Method]: {
        requestBody: {
          content: {
            "application/json": object | Array<object>
          }
        }
      }
    }
  },
  Path extends UrlPaths<paths>,
  Method extends HttpMethods
> = paths[Path][Method]['requestBody']['content']["application/json"]
```

##### openapi/src/types/auth.ts
```typescript
import { RequestBodyType, ResponseBodyType } from '../utils/helper'
import { paths } from '../generatedTypes/settings'

export type getSettingsResponseType = ResponseBodyType<paths, '/auth', 'get'>
export type patchSettingsRequestType = RequestBodyType<paths, '/auth', 'patch'>
```

``getSettingsResponseType``や``patchSettingsRequestType``をバックエンド・フロントエンドでimportして使用します。

## **APIのバリデーションにOASを用いる**
express-openapi-validatorは、手軽かつ強力にバリデーションとしてOASを利用できます。

### express-openapi-validator
使い方は簡単です。

下記のように関数を用意し、ミドルウェアとして各APIで使用します。

```typescript
// api/src/middlewares/openapiValidator.ts
import { Request, Response, NextFunction } from 'express'
import * as OpenApiValidator from 'express-openapi-validator'
import { OpenApiRequestHandler } from 'express-openapi-validator/dist/framework/types'

export const openApiValidator = (path: string): OpenApiRequestHandler[] => {
  return OpenApiValidator.middleware({
    apiSpec: `../openapi/src/docs/${path}/index.yml`, //読み込むOASファイルのパス
    validateResponses: {
      removeAdditional: true, //OASに存在しないキーがパラメータに含まれる場合は取り除く。
    },
    validateResponses: true,
  })
}

// api/src/router/auth.ts
router.use(openApiValidator('auth'))
```

``openApiValidator``はオプションの指定により、定義外のリクエスト/レスポンスが発生した場合の挙動を多様に設定できます。

## まとめ
本記事では、OASを用いた下記2点の活用について述べました。
1. openapi-typescriptを用いて、型を生成し、バックエンド・フロントエンドで共用する
2. express-openapi-validatorを用いて、APIのバリデーションを実装する

これらの活用によって、よりOASに依存したスキーマ駆動の開発を実現しています。
バックエンド・フロントエンド双方がOASに依存することで、コードの品質を担保し、バグの発生を防ぎます。

少しでもご参考になれば、幸いです。











